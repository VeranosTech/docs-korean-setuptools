
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>파이썬 에그의 내부 구조 &#8212; setuptools 36.2.7 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '36.2.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="search" title="Search" href="search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index_ko.html">setuptools 36.2.7 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1><a class="toc-backref" href="#id15">파이썬 에그의 내부 구조</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>STOP! 이 문서는 당신이 읽어야 하는 첫번째 문서가 아님!</p>
<div class="contents topic" id="id2">
<p class="topic-title first">** 목차 **</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id15">파이썬 에그의 내부 구조</a><ul>
<li><a class="reference internal" href="#id3" id="id16">에그와 포맷</a><ul>
<li><a class="reference internal" href="#id4" id="id17">코드와 리소스</a></li>
<li><a class="reference internal" href="#id5" id="id18">프로젝트 메타데이터</a></li>
<li><a class="reference internal" href="#id6" id="id19">파일 이름이 포함된 메타 데이터</a></li>
<li><a class="reference internal" href="#id7" id="id20">에그 링크</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8" id="id21">표준 메타데이터</a><ul>
<li><a class="reference internal" href="#txt" id="id22"><code class="docutils literal"><span class="pre">.txt</span></code> 파일 포맷</a></li>
<li><a class="reference internal" href="#id9" id="id23">종속성 메타데이터</a><ul>
<li><a class="reference internal" href="#requires-txt" id="id24"><code class="docutils literal"><span class="pre">requires.txt</span></code></a></li>
<li><a class="reference internal" href="#setup-requires-txt" id="id25"><code class="docutils literal"><span class="pre">setup_requires.txt</span></code></a></li>
<li><a class="reference internal" href="#dependency-links-txt" id="id26"><code class="docutils literal"><span class="pre">dependency_links.txt</span></code></a></li>
<li><a class="reference internal" href="#depends-txt" id="id27"><code class="docutils literal"><span class="pre">depends.txt</span></code> – 구식, 생성하지 말 것!</a></li>
</ul>
</li>
<li><a class="reference internal" href="#namespace-packages-txt-namespace-package-metadata" id="id28"><code class="docutils literal"><span class="pre">namespace_packages.txt</span></code> – Namespace Package Metadata</a></li>
<li><a class="reference internal" href="#entry-points-txt-entry-point-plugin-metadata" id="id29"><code class="docutils literal"><span class="pre">entry_points.txt</span></code> – “Entry Point”/Plugin Metadata</a></li>
<li><a class="reference internal" href="#scripts" id="id30"><code class="docutils literal"><span class="pre">scripts</span></code> 서브디렉토리</a></li>
<li><a class="reference internal" href="#zip" id="id31">Zip이 지원하는 메타데이터</a><ul>
<li><a class="reference internal" href="#native-libs-txt" id="id32"><code class="docutils literal"><span class="pre">native_libs.txt</span></code></a></li>
<li><a class="reference internal" href="#eager-resources-txt" id="id33"><code class="docutils literal"><span class="pre">eager_resources.txt</span></code></a></li>
<li><a class="reference internal" href="#zip-safe-not-zip-safe" id="id34"><code class="docutils literal"><span class="pre">zip-safe</span></code> 과 <code class="docutils literal"><span class="pre">not-zip-safe</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#top-level-txt" id="id35"><code class="docutils literal"><span class="pre">top_level.txt</span></code> – 충돌 관리 메타데이터</a></li>
<li><a class="reference internal" href="#sources-txt" id="id36"><code class="docutils literal"><span class="pre">SOURCES.txt</span></code> – 소스 파일 매니페스트</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id10" id="id37">다른 기술적인 고려사항</a><ul>
<li><a class="reference internal" href="#zip-file" id="id38">Zip File 문제</a><ul>
<li><a class="reference internal" href="#id11" id="id39">추출 프로세스</a></li>
<li><a class="reference internal" href="#id12" id="id40">확장 임포트 래퍼</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id13" id="id41">설치 및 경로 관리 문제</a><ul>
<li><a class="reference internal" href="#id14" id="id42">스크립트 래퍼</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id16">에그와 포맷</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>“파이썬 에그”는 파이썬 프로젝트, 코드 포함, 리소스 그리고 메타 데이터의 특정 버전의 릴리즈를 구체화하는 논리적인 구조이다. 파이썬 에그를 물리적으로 인코딩할 수 있는 다양한 포맷이 있다. 그리고 다른 것들도 개발되어진다. 그러나 파이썬 에그의 주요 원리는 에그가 발견될 수 있어야하고 임포트가 가능해야한다는 것이다. 즉,
파이썬 애플리케이션이 쉽고 효율적으로 시스템에 어떤 에그가 존재하는지를 알 수 있어야 한다. 그리고
올바른 에그의 내용이 임포트될 수 있게 보증해야한다.</p>
<p>파이썬 에그를 위해 현재 두 가지 포맷이 구현되어있다.:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">.egg</span></code> 포맷 : 프로젝트의 메타데이터를 포함하고 있는 <code class="docutils literal"><span class="pre">EGG-INFO</span></code> 하위디렉토리와 함께프로젝트의 코드와 리소스를 포함하는 디렉토리나 zip파일</li>
<li><code class="docutils literal"><span class="pre">.egg-info</span></code> 포맷: 직접적으로 프로젝트의 메타데이터를 포함하고 있는 프로젝트의 코드와 리소스에 인접하게 위치한 파일 또는 디렉토리</li>
</ol>
<p>두 포맷 모두 static 데이터 파일, 패키지, 논패키지 디렉토리, 파이썬 모듈과 C 확장 모듈을 포함하는 임의의 파이썬 코드와 리소스를 포함할 수 있다. 그러나 각각의 포맷은 다른 목적에 최적화 되어 있다.</p>
<p><code class="docutils literal"><span class="pre">.egg</span></code> 포맷은 배포와 코드의 언인스톨이나 업그레이드에 잘 맞춰져있다. 프로젝트는 기본적으로 다른 프로젝트의 코드와 리소스와 뒤섞이지 않은 단일 디렉토리 또는 파일 내에 자체적으로 포함된다. 동시에 설치된 프로젝트의 다양한 버전을 가질 수 있게 해준다. 각각의 프로그램은 사용하기를 원하는 버전을 선택할 수 있다.</p>
<p>반면에 <code class="docutils literal"><span class="pre">.egg-info</span></code> 포맷은 백워드 호환성, 퍼포먼스를 지원하기 위해 만들어졌다. 그리고 모든 프로젝트의 코드와 리소스를 단일 디렉토리( <code class="docutils literal"><span class="pre">site-packages</span></code> )에 설치하기 위한 시스템 패키지 도구에 대한 설치를 쉽게 만들어준다. 반드시 <code class="docutils literal"><span class="pre">.pth</span></code> 파일이 필요하지 않고, 각각의 설치된 에그를 포함하기 위해 <code class="docutils literal"><span class="pre">sys.path</span></code> 를 변경할 필요가 없기 때문에 같은 디렉토리에 메타데이터를 위치시키는 것은 설치 과정을 단순화한다.</p>
<p>그러나 단점은 깨끗한 언인스톨이나 업그레이드를 제공하지 않는 것이다. 물론 프로젝트의 싱글 버전이 주어진 디렉터리에 설치될 수는 있다. 그러므로, 패키지 관리 도구의 지원이 요구된다. ( 이러한 이유로 setuptools의 “install” 명령은 이러한 유형의 에그 설치를 “단일 버전, 외부 관리” 로 간주한다.)
또한 다른 설치 소스로부터 복사하는데 충분한 데이터를 가지고 있지 않다. <code class="docutils literal"><span class="pre">.egg-info</span></code> 설치를 위해 이를 할 수 없지만, easy_install은 <code class="docutils literal"><span class="pre">.egg</span></code> 파일이나 디렉토리를 타겟의 위치에 복사하여 애플리케이션을 제공할 수 있다. 어떤 코드와 어떤 리소스가 특정 에그에 속해 있는지 구별할 수 있는 방법이 없기 때문이다. 단일 설치 위치에 함께 “scrambled” 된 에그가 있을 수도 있다. 그리고 <code class="docutils literal"><span class="pre">.egg-info</span></code> 포맷은 현재 설치된 파일의 리스트를 보여줄 방법을 포함하고 있지 않다. ( 이는 아마 후에 바뀔 수 있다. )</p>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id17">코드와 리소스</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>코드와 리소스의 레이아웃은 파이썬의 일반적인 임포트 레이아웃(상대적인 에그의 기본 위치)에 의해 지시되어진다.</p>
<p><code class="docutils literal"><span class="pre">.egg</span></code> 포맷에 대한 기본 위치는 <code class="docutils literal"><span class="pre">.egg</span></code> 그 자체이다. 즉, <code class="docutils literal"><span class="pre">.egg</span></code> 의 파일 이름 또는 디렉토리 이름에 <code class="docutils literal"><span class="pre">sys.path</span></code> 를 추가하는 것은 내용을 임포트할 수 있게 만든다.</p>
<p>그러나 <code class="docutils literal"><span class="pre">.egg-info</span></code> 포맷에 대한 기본 위치는 <code class="docutils literal"><span class="pre">.egg-info</span></code> 를 포함하는 디렉토리이다. 그러므로 에그를 임포트 할 수 있게 하기 위해  <code class="docutils literal"><span class="pre">sys.path</span></code> 를 더해줘야한다.
( 설치된 <code class="docutils literal"><span class="pre">.egg-info</span></code> 파일 또는 디렉토리를 가진다면, <code class="docutils literal"><span class="pre">sys.path</span></code> 디렉토리에 패키지 일반 설치는 “egg”를 만드는 것이 가능하다는 것을 의미한다.)</p>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id18">프로젝트 메타데이터</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>에그가 단지 코드와 리소스만 포함한다면, <code class="docutils literal"><span class="pre">sys.path</span></code> 에서 다른것들과 다른 디렉토리나 zip파일과의 차이점이 없을 것이다. 그러므로, 메타데이터 파일이나 디렉토리를 사용하여 메타데이터를 반드시 포함해야한다.</p>
<p><code class="docutils literal"><span class="pre">.egg</span></code> 포맷의 경우, 메타데이터는 <code class="docutils literal"><span class="pre">.egg</span></code> 파일이나 디렉토리 내의 <code class="docutils literal"><span class="pre">EGG-INFO</span></code> 서브디렉토리에 위치한다. <code class="docutils literal"><span class="pre">.egg-info</span></code> 포맷의 경우 메타데이터는 <code class="docutils literal"><span class="pre">.egg-info</span></code> 디렉토리 자체 내에 저장된다.</p>
<p>모든 에그가 가져야 하는 가장 작은 프로젝트 메타데이터는 표준 파이썬 <code class="docutils literal"><span class="pre">PKG-INFO</span></code> 파일이다. 이는 포맷에 적합한 메타 데이터 디렉토리에 위치한다.</p>
<p>이것이 유일하게 포함된 메타데이터일 수도 있기 때문에 <code class="docutils literal"><span class="pre">.egg-info</span></code> 포맷의 에그는 디렉토리가 아니어도 된다. 단지 <code class="docutils literal"><span class="pre">PKG-INFO</span></code> 메타데이터를 직접적으로 포함하는 <code class="docutils literal"><span class="pre">.egg-info</span></code> 파일이다. 이는 하나의 파일을 저장하기 위해 디렉토리를 만드는 것을 할 필요를 없애준다. setuptools가 항상 다른 메타데이터를 포함하고 있기 때문에, 이 옵션은 <code class="docutils literal"><span class="pre">.egg</span></code> 포맷에서는 이용가능하지않다. (사실, setuptools는 그 자체로 <code class="docutils literal"><span class="pre">.egg-info</span></code> 파일을 발생시키지 않는다. 요구사항이 쉽게 다른 도구( 파이썬2.5에서 distutils 같은 )에 의해 충족되게 하기 위해 파일 사용에 대한 지원이 추가된다.</p>
<p><code class="docutils literal"><span class="pre">PKG-INFO</span></code> 파일 외에도, 에그의 메타데이터 디렉토리는 또한 다양한 선택적인 표준 메타데이터의 형식
(아래의 <a class="reference internal" href="#id8">표준 메타데이터</a> 섹션을 봐라.) 을 나타내는 파일과 디렉토리 또는 프로젝트에서 요구되는 사용자 정의 메타데이터를 포함할 수 있다. 예를 들면, 몇몇의 프로젝트는 애플리케이션 플러그인을 설명하기 위해 메타데이터 포맷을 정의할 수 있다. 그리고 이 포맷의 메타데이터는 프로젝트 작성자가 프로젝트의 메타 데이터 디렉토리에 포함시킨다.</p>
</div>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id19">파일 이름이 포함된 메타 데이터</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>설치된 프로젝트의 성질 및 프로젝트 간의 의존성의 런타임 해석을 허용하기 위해 일정량의 정보가 에그 파일 이름에 포함됩니다.
최소한, 이것은 프로젝트 이름을 포함하고 이상적으로는 프로젝트 버전 넘버도 포함을 할 것이다. 플랫폼 특정 C 코드가 포함된 경우, 그것은 선택적으로 타겟 파이썬 벼젼과 요구되는 런타임 플랫폼 또한 포함할 수 있다. 에그 파일이름의 syntax는 다음과 같다.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">name</span> <span class="p">[</span><span class="s2">&quot;-&quot;</span> <span class="n">version</span> <span class="p">[</span><span class="s2">&quot;-py&quot;</span> <span class="n">pyver</span> <span class="p">[</span><span class="s2">&quot;-&quot;</span> <span class="n">required_platform</span><span class="p">]]]</span> <span class="s2">&quot;.&quot;</span> <span class="n">ext</span>
</pre></div>
</div>
<p>처음에 <code class="docutils literal"><span class="pre">safe_name()</span></code> 와 <code class="docutils literal"><span class="pre">safe_version()</span></code> 를 사용하여 처리한 후에,  “name”과 “version”은 <code class="docutils literal"><span class="pre">pkg_resources</span></code> 에 의해 제공된 <code class="docutils literal"><span class="pre">to_filename()</span></code> 함수를 사용해서 이스케이프 되어야 한다.
후자의 두 함수는 나중에 파일 이름의 이 부분을 “unescape” 하는데 사용될 수도 있다.
(이러한 변형에 대한 자세한 설명에 대해서는 <code class="docutils literal"><span class="pre">pkg_resources</span></code> 메뉴얼의 “Parsing Utilities” 를 봐라.)</p>
<p>“pyver” 문자열은 파이썬의 주요 버전이다. <code class="docutils literal"><span class="pre">sys.version</span></code> 의 처음 세 문자에서 발견된다.
“required_platform” 은 본질적으로 distutil <code class="docutils literal"><span class="pre">get_platform()</span></code> 문자열이다. 그러나 Mac OS 버전을 적절하게
구별하기 위한 개선도 있다. ( 더 자세한 사항을 원한다면, <code class="docutils literal"><span class="pre">pkg_resources</span></code> 메뉴얼의 “Platform Utilities” 섹션에서 <code class="docutils literal"><span class="pre">get_build_platform()</span></code> 문서를 봐라.)</p>
<p>마지막으로 적절한 에그의 형식을 위해 “ext” 는 <code class="docutils literal"><span class="pre">.egg</span></code> 이거나 <code class="docutils literal"><span class="pre">.egg-info</span></code> 이다.</p>
<p>일반적으로 에그의 파일이름은 적어도 프로젝트 이름과 버전을 포함해야한다. 이는 버전 넘버를 결정하기 위해 에그의 PKG-INFO 를 읽지 않고 런타임 시스템이 바람직한 프로젝트 버전을 찾는 것을 허락한다.</p>
<p>그러나 <code class="docutils literal"><span class="pre">.egg</span></code> 파일이 <code class="docutils literal"><span class="pre">bdist_egg</span></code> 명령을 통해서 빌드되거나 또는 <code class="docutils literal"><span class="pre">.egg_info</span></code> 디렉토리가 <code class="docutils literal"><span class="pre">install_egg_info</span></code> 명령에 의해 설치될 때 setuptools는 단지 파일 이름에서 버전 넘버를 포함한다.
원래의 소스 트리 사용을 위해 메타데이터를 발생시킬 때, 그것은 단지 프로젝트 이름만을 포함한다. 그래서 디렉토리는 프로젝트 버전이 바뀔때마다 재명명 되지 않을 것이다.</p>
<p>이는 특히 버전 넘버가 빈번하게 변경될 때 중요하다. 그리고 소스 메타데이터 디렉토리는 나머지 프로젝트와 함께 버전 컨트롤 하에 보관된다. ( 프로젝트의 소스에 setup 스크립트의 데이터에서 setuptools가 생성하지 않은 프로젝트-정의 메타 데이터가 포함되어 있는 경우일 것이다. )</p>
</div>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id20">에그 링크</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">.egg</span></code> 와 <code class="docutils literal"><span class="pre">.egg-info</span></code> 포맷에 더해서, 때때로 우연히 만날 수 있는 세번째 에그와 관련된 확장이 있다.: <code class="docutils literal"><span class="pre">.egg-link</span></code> 파일</p>
<p>엄밀히 말해서,이러한 파일들은 에그가 아니다. 파일들은 단순히 바람직한 위치에 물리적으로 설치되지 않은 에그를 참조하는 방법을 제공한다. 그리고 바람직한 위치가 아닌 다른 위치에서 개발된 “installing” 코드를 지원하기 위해  주로 심볼릭 링크 대신 크로스 플랫폼으로 존재한다.
예를 들면, 사용자가 애플리케이션 플러그인을 홈 디렉토리에서 개발하고 있다면, 플러그인은 애플리케이션 플러그인 디렉토리에 설치될 필요가 있다. “setup.py develop -md /path/to/app/plugins” 을 실행하는 것은 <code class="docutils literal"><span class="pre">.egg-link</span></code> 파일을 <code class="docutils literal"><span class="pre">/path/to/app/plugins</span></code> 에 설치할 것이다. 이는 에그 런타임 시스템에게 실제 에그를 어디서 찾는지에 대해 알려준다. ( 사용자의 프로젝트 소시 디렉토리와 그것들의 <code class="docutils literal"><span class="pre">.egg_info</span></code> 서브 디렉토리)</p>
<p><code class="docutils literal"><span class="pre">.egg-link</span></code> 파일은 <code class="docutils literal"><span class="pre">.egg</span></code> 와 <code class="docutils literal"><span class="pre">.egg-info</span></code> 에 대한 포맷을 따라서 이름지어진다. 그러나 단지 프로젝트 이름만이 포함된다. 버전, 파이썬 버전 또는 플랫폼에 대한 정보는 포함되지 않는다. 런타임이 이용 가능한 에그를 찾을 때, <code class="docutils literal"><span class="pre">.egg-link</span></code> 파일은 오픈되어지고 실제 에그 파일/디렉토리 이름은 읽어진다.</p>
<p>각각의 <code class="docutils literal"><span class="pre">.egg-link</span></code> 파일은 새로운 라인을 가지고 있지 않은 단일 파일 또는 단일 디렉토리 네임을 포함해야한다.
이 파일 이름은 하나 또는 그 이상의 에그들의 기본 위치여야한다. 즉 이름은 <code class="docutils literal"><span class="pre">.egg</span></code> 로 끝나야한다. 그렇지 않으면 하나 이상의 <code class="docutils literal"><span class="pre">.egg-info</span></code> 포맷 에그의 부모 디렉토리여야 한다.</p>
<p>setuptools 0.6c6 기준으로는, 경로는 플랫폼 <code class="docutils literal"><span class="pre">.egg-link</span></code> 파일을 포함하는 디렉토리로부터 독립적인 상대 경로로 구체화 될 수도 있다. 그리고 두번째 라인은 파일 내에서 나타날 수도 있다. 그리고 에그의 기본 디렉토리로부터 그것들의 setup 스크립트 디렉토리까지 플랫폼 독립적인 상대 경로를 구체화한다. 이는 EasyInstall 같은 설치 도구가 프로젝트의 setup 디렉토리를 찾고 에그를 빌드하거나 다른 setup 명령을 수행하는 것을 허락한다.</p>
</div>
</div>
<div class="section" id="id8">
<h2><a class="toc-backref" href="#id21">표준 메타데이터</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>최소한의 <code class="docutils literal"><span class="pre">PKG-INFO</span></code> 메타데이터 외에도, 프로젝트는 아래에 설명된 다양한 표준 데이터 파일이나 디렉토리를 포함할 수 있다.
달리 명시된 경우를 제외하고, 이러한 파일과 디렉토리는 setup script에서 제공된 정보 또는 프로젝트의 코드와 리소스의 분석에 기초한 setuptools에 의해서 자동으로 발생된다.</p>
<p>대부분의 파일과 디렉토리는 “egg-info writers”에 의해 setuptools인 <code class="docutils literal"><span class="pre">egg_info</span></code> 커맨드가 실행되는 동안 발생된다. 그리고 setuptools의 <code class="docutils literal"><span class="pre">setup.py</span></code> 파일에 의해 정의된 <code class="docutils literal"><span class="pre">egg_info.writers</span></code> 엔트리 포인트 그룹에서 리스트로 표현된다.</p>
<p>프로젝트 저자는 그들의 메타데이터 작성자를 그룹내에서 엔트리 포인트로 등록할 수 있다. setuptools가 <code class="docutils literal"><span class="pre">eng_info</span></code> 명령을 실행하는 동안 프로젝트 고유의 메타 데이터 파일이나 디렉토리를 생성하게 한다. 이러한 저자가 새로운 메타데이터 포맷을 작성한 경우, 이를 문서화 하는 것은 프로젝트 저자에게 달려있다.</p>
<div class="section" id="txt">
<h3><a class="toc-backref" href="#id22"><code class="docutils literal"><span class="pre">.txt</span></code> 파일 포맷</a><a class="headerlink" href="#txt" title="Permalink to this headline">¶</a></h3>
<p>이 섹션에서 설명되는 파일은 <code class="docutils literal"><span class="pre">.txt</span></code> 확장자를 가진다. 또한 일련의 텍스트 행으로 구성된 간단한 어휘 포맷을 갖는다.
각 라인은 라인 피드 캐릭터로 끝난다.(플랫폼에 관계없이). 빈 줄과 첫 번째 공백이 아닌 문자가 <code class="docutils literal"><span class="pre">#</span></code> 인 것처럼, 각 줄의 선행 및 후행 공백은 무시된다. ( 이는 <code class="docutils literal"><span class="pre">pkg_resources</span></code> 모듈의 <code class="docutils literal"><span class="pre">yield_lines()</span></code> 함수에 의해 정의된 파싱 포맷이다.)</p>
<p>이 섹션에서 정의된 모든 <code class="docutils literal"><span class="pre">.txt</span></code> 파일은 이 포맷을 따른다. 그러나 일부는 또한 “sectioned” 파일로 그들의 내용은 섹션으로 나눠진다. 그리고 Windows “.ini” 형식과 비슷한 사각 괄호로 묶인 섹션 헤더를 사용한다.
이는 셕센내의 라인이 <code class="docutils literal"><span class="pre">.ini</span></code> 포맷을 따른다는 것은 의미하지는 않는다. 그러나 특정 파일에서 라인과 섹션 이름에 대한 설명은 개별 메타 데이터 파일의 문서를 봐라.
섹션화 된 파일은 <code class="docutils literal"><span class="pre">split_sections()</span></code> 함수를 사용하여 파싱할 수 있다. 자세한 내용은 <code class="docutils literal"><span class="pre">pkg_resources</span></code> 메뉴얼의 “Parsing Utilities” 섹션을 봐라.</p>
</div>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id23">종속성 메타데이터</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<div class="section" id="requires-txt">
<h4><a class="toc-backref" href="#id24"><code class="docutils literal"><span class="pre">requires.txt</span></code></a><a class="headerlink" href="#requires-txt" title="Permalink to this headline">¶</a></h4>
<p>이는 “sectioned” 텍스트 파일이다. 각 섹션은 <code class="docutils literal"><span class="pre">parse_requirements()</span></code> 함수에 의해 파싱된 “requirements”의 시퀀스이다. 완전한 requirement 파싱 syntax를 위해서는 <code class="docutils literal"><span class="pre">pkg_resources</span></code> 메뉴얼을 봐라.</p>
<p>이 파일에서 첫 번째 이름이 없는 섹션(첫 번째 섹션 헤더 앞에 있음)은 프로젝트의 핵심 요구사항이고, 이는 프로젝트를 위해 설치되어져야 한다. ( )</p>
<p>The first, unnamed section (i.e., before the first section header) in
this file is the project’s core requirements, which must be installed
for the project to function.( <code class="docutils literal"><span class="pre">setup()</span></code> 에 <code class="docutils literal"><span class="pre">install_requires</span></code> 를 사용하여 지정됨 )</p>
<p>이름이 있는 섹션은 프로젝트의 “extra” requirement를 설명한다. <code class="docutils literal"><span class="pre">setup()</span></code> 에 <code class="docutils literal"><span class="pre">extras_require</span></code> 키워드를 사용해서 지정된다. 이 섹션 이름은 선택적인 특징의 이름이고, 섹션 바디는 특징의 종속성을 나열한다.</p>
<p>이 파일을 직접적으로 조사하는 것은 일반적으로 필요한 것은 아니다.
<code class="docutils literal"><span class="pre">pkg_resources.Distribution</span></code> object는 프로젝트의 핵심과 선택적 종속성을  설명하는 <code class="docutils literal"><span class="pre">Requirement</span></code> object를 얻기위해 사용될 수 있는 <code class="docutils literal"><span class="pre">requires()</span></code> method 를 가진다.</p>
</div>
<div class="section" id="setup-requires-txt">
<h4><a class="toc-backref" href="#id25"><code class="docutils literal"><span class="pre">setup_requires.txt</span></code></a><a class="headerlink" href="#setup-requires-txt" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal"><span class="pre">requires.txt</span></code> 와 매우 비슷하게 except는 배포에 대한 <code class="docutils literal"><span class="pre">setup_requires</span></code> 파라미터에 의해 지정된 requirement를 나타낸다.</p>
</div>
<div class="section" id="dependency-links-txt">
<h4><a class="toc-backref" href="#id26"><code class="docutils literal"><span class="pre">dependency_links.txt</span></code></a><a class="headerlink" href="#dependency-links-txt" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal"><span class="pre">dependency_links</span></code> 키워드를 사용하여 <code class="docutils literal"><span class="pre">setup()</span></code> 에 지정한 의존성 URL 목록 (한 줄에 하나)
이는 직접 다운로드 URL일 수도 있고 또는 직접 다운로드 링크를 포함한 웹페이지의 URL일 수도 있다. 마치 사용자가 <code class="docutils literal"><span class="pre">--find-links</span></code> 명령 라인 옵션을 수동으로 제공한 것 처럼 종속성을 찾기 위해 EasyInstall에 의해 사용될 것이다.
이 옵션을 지정하는 것에 대한 정보와 EasyInstall이 <code class="docutils literal"><span class="pre">--find-links</span></code> URL을 어떻게 처리 하는지에 대한 정보를 원하면 setuptools 메뉴얼과 EasyInstall 메뉴얼을 봐라.</p>
</div>
<div class="section" id="depends-txt">
<h4><a class="toc-backref" href="#id27"><code class="docutils literal"><span class="pre">depends.txt</span></code> – 구식, 생성하지 말 것!</a><a class="headerlink" href="#depends-txt" title="Permalink to this headline">¶</a></h4>
<p>이 파일은 <code class="docutils literal"><span class="pre">requires.txt</span></code> 와 동일한 포맷을 가진다. 그러나 구식이므로 사용하지 말아야 한다.
가장 초기의 setuptools 버전은 사용자가 수동으로 이 파일을 만들고 유지하기를 요구했었다. 그래서 그것이 있다면, 런타임은 여전히 읽기를 지원한다. 하나가 이미 프로젝트의 소스인 <code class="docutils literal"><span class="pre">.egg-info</span></code> 디렉토리에 존재한다면 새로운 파일 이름은 <code class="docutils literal"><span class="pre">depends.txt``을</span> <span class="pre">덮어</span> <span class="pre">쓰지</span> <span class="pre">않고</span> <span class="pre">``setup()</span></code> 정보로부터 자동적으로 만들어진다.</p>
</div>
</div>
<div class="section" id="namespace-packages-txt-namespace-package-metadata">
<h3><a class="toc-backref" href="#id28"><code class="docutils literal"><span class="pre">namespace_packages.txt</span></code> – Namespace Package Metadata</a><a class="headerlink" href="#namespace-packages-txt-namespace-package-metadata" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">setup()</span></code> 에 <code class="docutils literal"><span class="pre">namespace_packages</span></code> 키워드가 주어졌을 때의 네임스페이스 패키지 네임 목록이다.
네임스페이스 패키지에 대한 더 많은 정보를 알고 싶다면 setuptools와 <code class="docutils literal"><span class="pre">pkg_resources</span></code> 에 대한 메뉴얼을 봐라.</p>
</div>
<div class="section" id="entry-points-txt-entry-point-plugin-metadata">
<h3><a class="toc-backref" href="#id29"><code class="docutils literal"><span class="pre">entry_points.txt</span></code> – “Entry Point”/Plugin Metadata</a><a class="headerlink" href="#entry-points-txt-entry-point-plugin-metadata" title="Permalink to this headline">¶</a></h3>
<p>이는 “sectioned” 텍스트 파일이고 텍스트 파일의 내용은 <code class="docutils literal"><span class="pre">setup()</span></code> 에 제공된 <code class="docutils literal"><span class="pre">entry_points</span></code> 키워드를 인코딩한다. 모든 섹션은 이름이 있고, 섹션 이름은 상응하는 섹션의 엔트리 포인트가 등록 되어져 있는 곳에 엔트리 포인트 그룹을 지정한다.</p>
<p>각 섹션은 “entry point” 라인의 시퀀스이고, <code class="docutils literal"><span class="pre">EntryPoint.parse</span></code> classmethod 를 통해 파싱이 가능하다.</p>
<p>완전한 엔트리 포인트 파싱 syntax에 대해서는 <code class="docutils literal"><span class="pre">pkg_resources</span></code> 메뉴얼을 봐라.</p>
<p>이 파일을 직접적으로 파싱할 필요는 없다. <code class="docutils literal"><span class="pre">pkg_resources</span></code> 모듈은 위치를 알아내고 엔트리 포인트를 자동으로 로딩하기 위해 다양한 API를 제공한다. 엔트리 포인트의 본질과 사용에 대한 상세 사항은 setuptools와 <code class="docutils literal"><span class="pre">pkg_resources</span></code> 메뉴얼을 참고해라.</p>
</div>
<div class="section" id="scripts">
<h3><a class="toc-backref" href="#id30"><code class="docutils literal"><span class="pre">scripts</span></code> 서브디렉토리</a><a class="headerlink" href="#scripts" title="Permalink to this headline">¶</a></h3>
<p>이 디렉토리는 현재 setuptools의 <code class="docutils literal"><span class="pre">bdist_egg</span></code> 명령에 의해 빌드된``.egg`` 파일에 의해서만 만들어진다.
이 디렉토리는 모든 프로젝트의 전통적인 스크립트의 복사본을 포함할 것이다. ( <code class="docutils literal"><span class="pre">script</span></code> 키워드를 <code class="docutils literal"><span class="pre">setup()</span></code> 에 사용하여 지정됨). 이것은 <code class="docutils literal"><span class="pre">.egg</span></code> 파일이 설치될 때 재구성 될 수 있도록 하기 위함이다.
스크립트는 distutils의 표준 <code class="docutils literal"><span class="pre">install_scripts</span></code> 명령을 사용하여 여기에 위치한다. 그래서 <code class="docutils literal"><span class="pre">#!</span></code> 라인은 에그가 빌드된 곳에 파이썬 설치를 반영한다. 그러나 스크립트를 로컬 스크립트 설치 디렉토리에 복사하는 것 대신에, sys.path가 에그와 에그에 종속되는 것을 확실히 한 후에, 포함하는 EasyInstall은 짧은 egg 내부로부터 원래의 스크립트를 발생시키는 래퍼 스크립트를 작성한다. <a class="reference internal" href="#id14">스크립트 래퍼</a> 에 대해 더 알고 싶다면, 아래의 섹션 <a class="reference internal" href="#id13">설치 및 경로 관리 문제</a> 을 참고해라.</p>
</div>
<div class="section" id="zip">
<h3><a class="toc-backref" href="#id31">Zip이 지원하는 메타데이터</a><a class="headerlink" href="#zip" title="Permalink to this headline">¶</a></h3>
<div class="section" id="native-libs-txt">
<h4><a class="toc-backref" href="#id32"><code class="docutils literal"><span class="pre">native_libs.txt</span></code></a><a class="headerlink" href="#native-libs-txt" title="Permalink to this headline">¶</a></h4>
<p>C 확장과 에그에 있는 다른 동적 링크 라이브러리의 목록.
경로들은 <code class="docutils literal"><span class="pre">/</span></code> 로 구분된다. 그리고 에그의 기본 위치에서 상대적이다.</p>
<p>이 파일은 <code class="docutils literal"><span class="pre">bdist_egg</span></code> 처리의 일부로 생성되고 <code class="docutils literal"><span class="pre">.egg</span></code> 파일에서만 나타난다.
( 그리고 <code class="docutils literal"><span class="pre">.egg</span></code> 디렉토리들은 그들은 언패킹함으로 생성된다.)
직접 연결이 있는 경우, 모든 라이브러리가 동시에 에그로부터 추출되는 것을 확실히 하여야 한다.
라이브러리와 <code class="docutils literal"><span class="pre">.egg</span></code> 파일로부터의 리소스 추출물에 대해 더 많이 알고 싶다면, 아래의 <a class="reference internal" href="#zip-file">Zip File 문제</a> 섹션을
봐라.</p>
</div>
<div class="section" id="eager-resources-txt">
<h4><a class="toc-backref" href="#id33"><code class="docutils literal"><span class="pre">eager_resources.txt</span></code></a><a class="headerlink" href="#eager-resources-txt" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal"><span class="pre">eager_resources</span></code> 키워드를 <code class="docutils literal"><span class="pre">setup()</span></code> 에 지정된대로 리소스 파일 또는 디렉토리의 리스트
경로들은 <code class="docutils literal"><span class="pre">/</span></code> 로 구분된다. 그리고 에그의 기본 위치에서 상대적이다.</p>
<p>이름이 있는 리소스가 추출되거나 또는 <code class="docutils literal"><span class="pre">native_libs.txt</span></code> 에 나열된 native 라이브러리가 추출된다면, 여기에 나열된 리소스 파일과 또는 디렉토리들은 동시에 추출될 것이다.
어떤 특징이 사용되고 어떻게 작동되는지 뿐만 아니라 아래의 <a class="reference internal" href="#zip-file">Zip File 문제</a> 섹션에 대해 더 많은 정보를 알고 싶다면 setuptools 메뉴얼을 봐라.</p>
</div>
<div class="section" id="zip-safe-not-zip-safe">
<h4><a class="toc-backref" href="#id34"><code class="docutils literal"><span class="pre">zip-safe</span></code> 과 <code class="docutils literal"><span class="pre">not-zip-safe</span></code></a><a class="headerlink" href="#zip-safe-not-zip-safe" title="Permalink to this headline">¶</a></h4>
<p>이들은 길이가 0인 파일이며, 둘 중 하나가 있어야 한다.
<code class="docutils literal"><span class="pre">zip-safe</span></code> 가 존재한다면, 이는 <code class="docutils literal"><span class="pre">.egg</span></code> zipfile로 설치될 때, 프로젝트가 적절하게 작동할 것임을 의미한다.
반대로 <code class="docutils literal"><span class="pre">non-zip-safe</span></code> 가 있으면 이는 프로젝트가 <code class="docutils literal"><span class="pre">.egg</span></code> 파일로 설치되면 안된다는 것을 의미한다.
setuptools의 <code class="docutils literal"><span class="pre">setup()</span></code> 에 대한 <code class="docutils literal"><span class="pre">zip_safe</span></code> 옵션은 어떤 파일이 작성될 것인지를 결정한다. 옵션이 제공되지 않는다면, setuptools는 코드와 내용 분석에 기초를 둔 패키지가 작동하는지 여부에 대한 평가를 직접 시도한다.</p>
<p>설치를 할 때 파일이 없으면, Easyinstall은 기본적으로 프로젝트의 압축을 풀어야한다고 가정한다.
( 그러나 EasyInstall에 대한 명령 행 옵션은 기존의 <code class="docutils literal"><span class="pre">zip-safe</span></code> 또는 <code class="docutils literal"><span class="pre">not-zip-safe</span></code> 파일보다 우선시 된다.</p>
<p>이러한 플래그 파일은 단지 <code class="docutils literal"><span class="pre">.egg</span></code> 파일은 언패킹함으로써 만들어진 <code class="docutils literal"><span class="pre">bdist_egg``와</span> <span class="pre">``.egg</span></code> 디렉토리에 의해 발생된 <code class="docutils literal"><span class="pre">.egg</span></code> 파일에서만 나타난다는 점을 주목하자.</p>
</div>
</div>
<div class="section" id="top-level-txt">
<h3><a class="toc-backref" href="#id35"><code class="docutils literal"><span class="pre">top_level.txt</span></code> – 충돌 관리 메타데이터</a><a class="headerlink" href="#top-level-txt" title="Permalink to this headline">¶</a></h3>
<p>이 파일은 탑레벨 모듈과 프로젝트에 의해 제공된 패키지 이름의 목록이다. 한 줄에 하나의 파이썬 식별자가 있다.</p>
<p>서브패키지들은 포함되지 않는다. 그것의 <code class="docutils literal"><span class="pre">top_level.txt</span></code> 내에 잇는 <code class="docutils literal"><span class="pre">foo.bar</span></code> 와 <code class="docutils literal"><span class="pre">foo.baz</span></code> 를 모두를 포함하는 프로젝트는 단지 하나의 줄, <code class="docutils literal"><span class="pre">foo</span></code> 만 포함할 것이다.</p>
<p>런타임 시에, 에그가 포함된 패키지들이 이미 임포트 되어졌을 때, 에그가 <code class="docutils literal"><span class="pre">sys.path</span></code> 에 더해지면 경고를 알려주기 위해 <code class="docutils literal"><span class="pre">pkg_resources</span></code> 에 의해 이 데이터가 사용된다.</p>
<p>( 또한 한 번 설치시, 에그가 아닌 패키지와의 충돌을 감지하는 데 사용되었지만, 최근 버전에서는 setuptools는 항상 에그가 아닌 패키지를 오버라이드 하는 방법으로 에그를 설치하기 때문에 문제를 발생시키지 않는다.)</p>
</div>
<div class="section" id="sources-txt">
<h3><a class="toc-backref" href="#id36"><code class="docutils literal"><span class="pre">SOURCES.txt</span></code> – 소스 파일 매니페스트</a><a class="headerlink" href="#sources-txt" title="Permalink to this headline">¶</a></h3>
<p>이 파일은 distutils 의 <code class="docutils literal"><span class="pre">MANIFEST</span></code> 파일과 동등하다. 이 차이점은 아래에서 보여진다.</p>
<ul class="simple">
<li>파일 이름은 경로 구분자로 <code class="docutils literal"><span class="pre">/</span></code> 를 사용한다. 이는 읽을 때마다 플랫폼 특정 경로로 다시 변환해야한다.</li>
<li>파일은 자동으로 <code class="docutils literal"><span class="pre">egg_info</span></code> 또는 <code class="docutils literal"><span class="pre">sdist</span></code> 명령이 실행될 때마다 setuptools에 의해 발생하고 사용자가 편집할 수 없다.</li>
</ul>
<p>이 메타데이터가 배포된 에그에 포함되더라도, 그것은 실제로 어떤 목적을 위해 런타임시에 사용되는 것은 아니다.
기능은 원래 저자의 시스템에서 revision control medatadata를 사용해서 만들어진 목록이 있더라도 setuptools-built <em>source</em> distributions이 정확하게 어떤 파일이 프로젝트 소스의 일부인지 발견할 수 있도록 보장해준다.</p>
<p>다른 말로는, <code class="docutils literal"><span class="pre">SOURCES.txt</span></code> 는 배포된 에그에 포함되기 위한 런타임 값이 거의 없거나 전혀 없다.
그리고 <code class="docutils literal"><span class="pre">bdist_egg</span></code> 와 <code class="docutils literal"><span class="pre">install_egg_info</span></code> 명령의 미래 버전은 설치 또는 배포 전에 이를 제거한다.
그러므로, 원본 소스 디렉토리 또는 소스 배포판 외부에서 사용할 수 있다는 것에 의존하면 안된다.</p>
</div>
</div>
<div class="section" id="id10">
<h2><a class="toc-backref" href="#id37">다른 기술적인 고려사항</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<div class="section" id="zip-file">
<h3><a class="toc-backref" href="#id38">Zip File 문제</a><a class="headerlink" href="#zip-file" title="Permalink to this headline">¶</a></h3>
<p>zip 파일이 디렉토리와 비슷하지만 완전히 디렉토리에 적합하지 않다.
대부분의 플랫폼은 zip 파일에 포함된 동적 링크 라이브러리를 지원하지 않는다. 그래서 직접 <code class="docutils literal"><span class="pre">.egg</span></code> zip 파일로부터 C 확장을 임포트 하는 것은 불가능하다. 유사하게 많은 파이썬 또는 C에 라이브러리가 있고 이는 실제 운영체제 파일 이름은 요구한다. 그리고 임의의 “file-like”(파일 같은) object 또는 in-memory 문자열에서 작동하지 않는다. 그러므로 zip 파일의 내용에서 직접 동작할 수 없다.</p>
<p>이러한 문제를 해결하기 위해, <code class="docutils literal"><span class="pre">pkg_resources</span></code> 모듈은 리소스의 내용 또는 리소스에 대한 참인 운영체제 파일 이름 획득을 지우너하기 위해 “resource API” 를 제공한다. 리소스를 포함하는 에그가 디렉토리라면 리소스의 실제 파일 이름은 단순히 반환된다. 그러나 에그가 zip 파일이라면 리소스는 처음에 캐시 디렉토리로부터 추출되고 캐시에 있는 파일 이름이 반환될 것이다.</p>
<p>캐시 디렉토리는 <code class="docutils literal"><span class="pre">pkg_resources</span></code> API에 의해 결정된다.
자세한 사항을 위해서는 <code class="docutils literal"><span class="pre">set_cache_path()</span></code> 와 <code class="docutils literal"><span class="pre">get_default_cache()</span></code> 문서를 봐라.</p>
<div class="section" id="id11">
<h4><a class="toc-backref" href="#id39">추출 프로세스</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>리소스는 캐시 서브디렉토리에서 추출된다. 캐시 서브디렉토리의 이름은 <code class="docutils literal"><span class="pre">.egg</span></code> 파일 이름과 리소스에 대한 경로에 기초를 둔다. 이미 정확한 이름, 크기, 타임스탬프을 가진 파일이 있다면, 파일 이름은 요청자에게 반환된다. 그렇지 않으면 바람직한 파일은 처음에 <code class="docutils literal"><span class="pre">mkstemp(&quot;.$extract&quot;,target_dir)</span></code> 를 사용해서 만들어진 임시적인 이름으로 추출된다. 그리고, 마지막 이름으로 이름이 바꾸기 전에, 타임스탬프는 zip 파일의 타임 스탬프와 일치하도록 설정된다.
( 일부 충돌 감지 및 해결 코드는 이름을 바꿀 때 Windows가 파일을 덮어 쓰지 않는다는 사실을 처리하는 데 사용된다. )</p>
<p>리소스 디렉토리가 요구되면, 모든 컨텐츠는 디렉토리 이름은 모두 유효한 것처럼 사용하는 것을 보증하기 위해 재귀적으로 이 방식을 통해 추출된다.</p>
<p>추출을 위해 요청된 리소스가 <code class="docutils literal"><span class="pre">native_libs.txt</span></code> 또는 <code class="docutils literal"><span class="pre">eager_resources.txt</span></code> 메타데이터 파일에서 나열된다면, 두 파일에 나열된 모든 리소스는 요청된 리소스의 파일이름이 반환되기 전에 추출될 것이다. 그러므로 그들에 의해 사용되는 C 확장과 데이터가 동시에 사용 가능함을 모든 것을 보장한다.</p>
</div>
<div class="section" id="id12">
<h4><a class="toc-backref" href="#id40">확장 임포트 래퍼</a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<p>파이썬의 빌트인 zip 임포트 기능은 zip파일에서 C 확장 모듈을 로딩하는 것을 지원하지 않으므로, setuptools <code class="docutils literal"><span class="pre">bdist_egg</span></code> 명령은 그것을 작동하게 하는 특정한 임포트 래퍼를 생성시킨다.</p>
<p>래퍼는 상응하는 C 확장과 같은 모듈 이름을 가진 <code class="docutils literal"><span class="pre">.py</span></code> 파일들이다. (상응하는 <code class="docutils literal"><span class="pre">.pyc</span></code> 및 <code class="docutils literal"><span class="pre">.pyo</span></code> 파일도 포함)
이러한 래퍼는 zip 파일 내의 같은 패키지 디렉토리(또는 top-level 디렉토리)에 위치한다. 그래서 <code class="docutils literal"><span class="pre">foomodule.so</span></code> 는 상응하는 <code class="docutils literal"><span class="pre">foo.py</span></code> 를 얻게 될 것이다. 반면에 <code class="docutils literal"><span class="pre">bar/baz.pyd</span></code> 는 그에 상응하는 <code class="docutils literal"><span class="pre">bar/baz.py</span></code> 를 얻게 될 것이다.</p>
<p>이러한 래퍼 파일은 상응하는 C 확장의 파일명의 <code class="docutils literal"><span class="pre">pkg_resources</span></code> 를 요청하고 획득한 파일명을 사용하여 모듈을 리로드하는 파이썬 코드의 짧은 stanza를 포함한다. 이는 <code class="docutils literal"><span class="pre">pkg_resoures</span></code> 로 하여금 에그의 C 확장 모두가 (그리고 동반하는 “eager resources” 또한) C 라이브러리로의 연결을 시도하기 전에 캐시로 추출되는 것을 가능하도록 한다.</p>
<p>참고로 <code class="docutils literal"><span class="pre">.egg</span></code> 디렉토리는 또한 이러한 래퍼 파일을 포함한다는 것을 유의해라. 그러나, 파이썬의 디폴트 임포트 우선순위는 C 확장이 같은 이름의 파이썬 모듈보다 우선하여 에그가 집파일이지 않는 한 임포트 래퍼가 무시되도록 하는 것이다.</p>
</div>
</div>
<div class="section" id="id13">
<h3><a class="toc-backref" href="#id41">설치 및 경로 관리 문제</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>파이썬의 <code class="docutils literal"><span class="pre">sys.path</span></code> 초기 설정은 파이썬이 어떻게 시작되었는가 (예. 스크립트 vs. <code class="docutils literal"><span class="pre">-c</span></code> vs. 상호 통역기) 뿐만 아니라 파이썬의 버전과 설치 플랫폼에 따라 좌우된다.</p>
<p>실제로, 파이썬은 또한 코드의 직접적 조작 밖에 있는 <code class="docutils literal"><span class="pre">sys.path</span></code> 에 영향을 주는 데 있어 단 두 가지의 상대적으로 활발한 방식을 제공하는데, 그 두가지는 “PHYTONPATH” 환경 변인과 <code class="docutils literal"><span class="pre">.pth</span></code> 파일이다.</p>
<p>그러나 안전하고 지속적으로 환경 변인을 바꾸는 교차-플랫폼이 없이는, 이것은 <code class="docutils literal"><span class="pre">.pth</span></code> 파일을 <code class="docutils literal"><span class="pre">sys.pth</span></code> 의 지속적 배치에 있어 EasyInstall의 유일한 실제적 옵션으로 남겨둔다.</p>
<p>하지만 <code class="docutils literal"><span class="pre">.pth</span></code> 파일들은 정상적으로 작동시킬 수 있는 대상에 있어서 다소 엄격한 제한을 받는다. 이들은 로컬에서 설치된 <code class="docutils literal"><span class="pre">site-packages</span></code> 디렉토리 후에 <code class="docutils literal"><span class="pre">sys.path</span></code> 의 끝에만 디렉토리를 추가하며, 이들은 시작할 때 <code class="docutils literal"><span class="pre">site-packages</span></code>  디렉토리 내에서만 처리된다.</p>
<p>이는 해당 디렉토리에 쓰기 권한이 없는 사용자들이 파이썬이 읽을 <code class="docutils literal"><span class="pre">.pth</span></code> 파일을 만들 수 없으므로 그들에게 이중고이다. 또한 동정적인 시스템 관리자가 몇몇 다른 디렉토리들이 <code class="docutils literal"><span class="pre">.pth</span></code> 파일을 포함할 수 있도록 그들을 위해 <code class="docutils literal"><span class="pre">site.addsitedir()</span></code> 를 추가한다 하더라도, 그들의 경로는 여전히 <code class="docutils literal"><span class="pre">site-packages</span></code> 다음에 추가되므로 시스템 전체의 <code class="docutils literal"><span class="pre">site-packages</span></code> 내에 설치된 어떠한 새로운 버전도 추가할 수 없다.</p>
<p>따라서 이러한 문제를 해결하기 위해 EasyInstall은 두 가지 제2의 해결책을 적용한다.</p>
<p>첫 번째는 EasyInstall <code class="docutils literal"><span class="pre">sys.path</span></code> 를 조작하기 위해 <code class="docutils literal"><span class="pre">.pth</span></code> 파일의 “임포트” 기능을 구축하고, EasyInstall이 <code class="docutils literal"><span class="pre">.pth</span></code> 파일에 추가하는 모든 것이 항상 표준 라이브러리와 로컬 <code class="docutils literal"><span class="pre">site-packages</span></code> 디렉토리 전에 나타나도록 하는 것이다. 따라서, 파이썬으로 읽히는 <code class="docutils literal"><span class="pre">.pth</span></code> 파일을 쓰는 사용자가 그들의 패키지가 환경에서 가장 먼저 올 수 있도록 하는 것이 가능하다.</p>
<p>두 번째로, <code class="docutils literal"><span class="pre">PYTHONPATH</span></code> 디렉토리에 설치할 때 (<code class="docutils literal"><span class="pre">site-packages</span></code> 와 같은 “site” 디렉토리와 반대의 경우), EasyInstall은 또한 <code class="docutils literal"><span class="pre">site</span></code> 모듈의 특수한 버전을 설치할 것이다. 이 모듈은 <code class="docutils literal"><span class="pre">PYTHONPATH</span></code> 디렉토리 안에 있으므로 <code class="docutils literal"><span class="pre">site</span></code> 의 표준 라이브러리보다 우선적으로 통제권을 갖게 될 것이다. 이것은 “real” <code class="docutils literal"><span class="pre">site</span></code> 모듈을 불러오기 전에 <code class="docutils literal"><span class="pre">sys.path</span></code> 의 상태를 기록할 것이며, 그 이후에 에그가 항상 sys.path 내의 표준 라이브러리보다 앞서 나타나도록 하면서 그것의 <code class="docutils literal"><span class="pre">PYTHONPATH</span></code> 에 의해 정의된 다른 에그 및 <code class="docutils literal"><span class="pre">.pth</span></code> 로 규정된 순서에서 상대적인 순서가 되도록 하기 위해 필요한 모든 유지 보수를 포함하여 <code class="docutils literal"><span class="pre">PYTHONPATH</span></code> 내에 있는 모든 <code class="docutils literal"><span class="pre">.pth</span></code> 파일을 처리하게 된다.</p>
<p>이러한 변화의 최종적 결론은 <code class="docutils literal"><span class="pre">sys.path</span></code> 의 순서가 실행 시간에서 아래의 순서가 되는 것이다. :</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">sys.argv[0]</span></code> 디렉토리 또는 스크립트가 실행되지 않을 경우에는 빈 문자열</li>
<li>각 <code class="docutils literal"><span class="pre">PYTHONPATH</span></code> 디렉토리 내의 모든 <code class="docutils literal"><span class="pre">.pth</span></code> 파일에서 EasyInstall에 의해 설치된 모든 에그. 먼저 <code class="docutils literal"><span class="pre">PYTHONPATH</span></code> 명령, 그리고 일반적인 <code class="docutils literal"><span class="pre">.pth</span></code> 처리 명령의 순서 (<code class="docutils literal"><span class="pre">.pth</span></code> 파일명의 알파벳 순서를 말하는 것, 그리고 각 <code class="docutils literal"><span class="pre">.pth</span></code> 파일 내에서는 목록화된 순서.</li>
<li>각 “site” 디렉토리 (예. <code class="docutils literal"><span class="pre">site-packages</span></code> ) 내의 모든 <code class="docutils literal"><span class="pre">.pth</span></code> 파일에서 EasyInstall에 의해 설치된 모든 에그. <code class="docutils literal"><span class="pre">PYTHONPATH</span></code> 에서와 같은 순서 규칙을 따름.</li>
<li>원래 순서대로의 <code class="docutils literal"><span class="pre">PYTHONPATH</span></code> 디렉토리.</li>
<li>EasyInstall에 의해 설치된 에그가 아닌 <code class="docutils literal"><span class="pre">PYHTHONPATH</span></code> 에서 발견되는 <code class="docutils literal"><span class="pre">.pth</span></code> 파일에서의 모든 경로. 다시 동일한 상대적인 순서 규칙을 따름.</li>
<li>“site” 디렉토리 내의 모든 <code class="docutils literal"><span class="pre">.pth</span></code> 파일의 내용과 함께 표준 라이브러리와 “site” 디렉토리.</li>
</ol>
<p>섹션 1, 4, 6이 <code class="docutils literal"><span class="pre">sys.path</span></code> 를 위한 “normal” 파이썬 셋업을 구성함을 주목해라. 섹션 2와 3은 에그를 지원하기 위해 삽입되었으며, 섹션 5는 파이썬이 자동적으로 지원할 때 <code class="docutils literal"><span class="pre">PYTHONPATH</span></code> 의 <code class="docutils literal"><span class="pre">.pth</span></code> 파일들의 “normal” 시맨틱스가 되는 것을 에뮬레이트한다.</p>
<p><code class="docutils literal"><span class="pre">.pth</span></code> 파일들이 이러한 작업을 수행하도록 삽입된 실제 매직에 대한 주석 뿐 아니라 디자인에 투입된 상충의 더 깊은 논의를 원한다면, distutils-SIG 메일링 리스트에 대한 다음의 메시지를 보아라.:</p>
<ul class="simple">
<li><a class="reference external" href="http://mail.python.org/pipermail/distutils-sig/2006-February/006026.html">http://mail.python.org/pipermail/distutils-sig/2006-February/006026.html</a></li>
<li><a class="reference external" href="http://mail.python.org/pipermail/distutils-sig/2006-March/006123.html">http://mail.python.org/pipermail/distutils-sig/2006-March/006123.html</a></li>
</ul>
<div class="section" id="id14">
<h4><a class="toc-backref" href="#id42">스크립트 래퍼</a><a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>EasyInstall은 절대로 스크립트 설치 디렉토리에 프로젝트의 원래의 스크립트를 직접적으로 설치하지 않는다. 대신에, 그것은 원래의 스크립트를 불러오기 전에 먼저 프로젝트의 종속성이 sys.path에서 활성화될 수 있게 하는 짧은 래퍼 스크립트를 사용한다. 이러한 래퍼는 그것을 설치하기 위해 사용된 파이썬의 버전을 가리키는 #! 줄을 포함하며, 두 번째 줄에는 항상 스크립트 래퍼의 타입, 스크립트가 실행되기 위해 필요한 프로젝트 버전과 불러오기 되는 스크립트를 확인하는 정보를 가리키는 코멘트가 있다.</p>
<p>이러한 마커 라인의 내용은 아래와 같다.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="s2">&quot;# EASY-INSTALL-&quot;</span> <span class="n">script_type</span> <span class="s2">&quot;: &quot;</span> <span class="n">tuple_of_strings</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">script_type</span></code> 은 <code class="docutils literal"><span class="pre">SCRIPT</span></code> , <code class="docutils literal"><span class="pre">DEV-SCRIPT</span></code> 또는 <code class="docutils literal"><span class="pre">ENTRY-SCRIPT</span></code> 중의 하나이다. <code class="docutils literal"><span class="pre">tuple_of_strings</span></code> 파이썬 문자열 상수에서 콤마로 분리되는 순서이다. <code class="docutils literal"><span class="pre">SCRIPT</span></code> 와 <code class="docutils literal"><span class="pre">DEV-SCRIPT</span></code> 래퍼에서는 두 가지 문자열이 존재하는데, 프로젝트 버전 요구사항과 스크립트 이름(<code class="docutils literal"><span class="pre">scripts</span></code> 메타데이터 디렉토리 내에서의 파일명)이다. <code class="docutils literal"><span class="pre">ENTRY-SCRIPT</span></code> 래퍼에서는 세 가지 문자열이 존재하는데, 프로젝트 버전 요구사항, 엔트리 포인트 그룹명과 엔트리 포인트명이 있다. (엔트리 포인트 스크립트에 대한 더 많은 정보를 보려면 setuptools 매뉴얼의 “자동 스크립트 생성” 섹션을 보아라.)</p>
<p>각 케이스에서 프로젝트 버전 요구사항 문자열은 <code class="docutils literal"><span class="pre">pkg_resources</span></code> 모듈의 <code class="docutils literal"><span class="pre">Requirement.parse()</span></code> 로 분석 가능한 문자열이 될 것이다. <code class="docutils literal"><span class="pre">SCRIPT</span></code> 래퍼와 <code class="docutils literal"><span class="pre">DEV-SCRIPT</span></code> 사이의 유일한 차이는 <code class="docutils literal"><span class="pre">DEV-SCRIPT</span></code> 는 프로젝트의 소스 트리 내의 본래 소스 스크립트를 실제로 실행시키며 “setup.py develop” 명령이 실행되었을 때 생성된다는 것이다. 반면에 <code class="docutils literal"><span class="pre">SCRIPT</span></code> 래퍼는  상응하는 <code class="docutils literal"><span class="pre">.egg</span></code> 집파일 또는 디렉토리의 <code class="docutils literal"><span class="pre">EGG-INFO/scripts</span></code> 서브디렉토리에 쓰여진 “installed” 스크립트를 사용한다. (<code class="docutils literal"><span class="pre">.egg-info</span></code> 에그는 “setup.py develop” 케이스 외에는 그것과 관련된 스크립트 래퍼를 갖지 않는다.)</p>
<p>생성된 스크립트 래퍼의 마커 라인을 포함하는 목적은 설치된 스크립트의 인트로스펙션과 설치된 에그와의 관계를 촉진시키는 것이다. 예를 들어, 언인스톨레이션 도구는 어떤 스크립트가 안전하게 삭제될 수 있는지 그리고/또는 특정 에그가 언인스톨되었을 때 어떤 스크립트가 작동이 중단될지 알아보기 위해 이러한 데이터를 사용할 수 있다.</p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index_ko.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">파이썬 에그의 내부 구조</a><ul>
<li><a class="reference internal" href="#id3">에그와 포맷</a><ul>
<li><a class="reference internal" href="#id4">코드와 리소스</a></li>
<li><a class="reference internal" href="#id5">프로젝트 메타데이터</a></li>
<li><a class="reference internal" href="#id6">파일 이름이 포함된 메타 데이터</a></li>
<li><a class="reference internal" href="#id7">에그 링크</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">표준 메타데이터</a><ul>
<li><a class="reference internal" href="#txt"><code class="docutils literal"><span class="pre">.txt</span></code> 파일 포맷</a></li>
<li><a class="reference internal" href="#id9">종속성 메타데이터</a><ul>
<li><a class="reference internal" href="#requires-txt"><code class="docutils literal"><span class="pre">requires.txt</span></code></a></li>
<li><a class="reference internal" href="#setup-requires-txt"><code class="docutils literal"><span class="pre">setup_requires.txt</span></code></a></li>
<li><a class="reference internal" href="#dependency-links-txt"><code class="docutils literal"><span class="pre">dependency_links.txt</span></code></a></li>
<li><a class="reference internal" href="#depends-txt"><code class="docutils literal"><span class="pre">depends.txt</span></code> – 구식, 생성하지 말 것!</a></li>
</ul>
</li>
<li><a class="reference internal" href="#namespace-packages-txt-namespace-package-metadata"><code class="docutils literal"><span class="pre">namespace_packages.txt</span></code> – Namespace Package Metadata</a></li>
<li><a class="reference internal" href="#entry-points-txt-entry-point-plugin-metadata"><code class="docutils literal"><span class="pre">entry_points.txt</span></code> – “Entry Point”/Plugin Metadata</a></li>
<li><a class="reference internal" href="#scripts"><code class="docutils literal"><span class="pre">scripts</span></code> 서브디렉토리</a></li>
<li><a class="reference internal" href="#zip">Zip이 지원하는 메타데이터</a><ul>
<li><a class="reference internal" href="#native-libs-txt"><code class="docutils literal"><span class="pre">native_libs.txt</span></code></a></li>
<li><a class="reference internal" href="#eager-resources-txt"><code class="docutils literal"><span class="pre">eager_resources.txt</span></code></a></li>
<li><a class="reference internal" href="#zip-safe-not-zip-safe"><code class="docutils literal"><span class="pre">zip-safe</span></code> 과 <code class="docutils literal"><span class="pre">not-zip-safe</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#top-level-txt"><code class="docutils literal"><span class="pre">top_level.txt</span></code> – 충돌 관리 메타데이터</a></li>
<li><a class="reference internal" href="#sources-txt"><code class="docutils literal"><span class="pre">SOURCES.txt</span></code> – 소스 파일 매니페스트</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id10">다른 기술적인 고려사항</a><ul>
<li><a class="reference internal" href="#zip-file">Zip File 문제</a><ul>
<li><a class="reference internal" href="#id11">추출 프로세스</a></li>
<li><a class="reference internal" href="#id12">확장 임포트 래퍼</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id13">설치 및 경로 관리 문제</a><ul>
<li><a class="reference internal" href="#id14">스크립트 래퍼</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/formats_ko.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index_ko.html">setuptools 36.2.7 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright Python Packaging Authority.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>